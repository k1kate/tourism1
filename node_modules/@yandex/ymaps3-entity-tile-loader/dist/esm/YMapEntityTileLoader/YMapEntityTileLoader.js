var _a;
import { YMapEntityTileLoaderReactifyOverride } from './react/YMapEntityTileLoader';
import { getTilesForViewport } from './helpers/getTilesForViewport';
import throttle from 'lodash/throttle';
export class YMapEntityTileLoader extends ymaps3.YMapComplexEntity {
    constructor(props) {
        super({ removalDelay: 0, ...props }, { container: true });
        this._tiles = new Map();
        this._entities = new Map();
        this._markedForDeletion = new Set();
        this._listener = new ymaps3.YMapListener({
            onUpdate: ({ mapInAction }) => {
                if (!mapInAction) {
                    this._reconcileTiles();
                }
            }
        });
        this._addDirectChild(this._listener);
        this._requestRemoveFeatures = throttle(() => this._removeEntities(), this._props.removalDelay);
    }
    _onUpdate({ removalDelay }) {
        if (removalDelay !== undefined) {
            this._removeEntities();
            this._requestRemoveFeatures.cancel();
            this._requestRemoveFeatures = throttle(() => this._removeEntities(), removalDelay);
        }
    }
    _onDetach() {
        for (const child of this.children) {
            this.removeChild(child);
        }
        this._tiles.clear();
        this._entities.clear();
        this._requestRemoveFeatures.cancel();
    }
    _onAttach() {
        this._reconcileTiles();
    }
    _reconcileTiles() {
        const { projection, zoom, center, size } = this.root;
        const tilesForViewport = getTilesForViewport({
            projection,
            zoom,
            center,
            size,
            tileSize: this._props.tileSize
        });
        const tiles = new Map();
        for (const tile of tilesForViewport) {
            tiles.set(`${tile.tx}_${tile.ty}_${tile.tz}`, tile);
        }
        // Add new
        for (const [key, description] of tiles.entries()) {
            if (this._tiles.has(key))
                continue;
            const tile = {
                ...description,
                abortController: new AbortController(),
                entities: new Map(),
                promise: Promise.resolve()
            };
            tile.promise = this._fetchTile(tile);
            this._tiles.set(key, tile);
        }
        // Remove old tiles and features
        for (const [key, tile] of this._tiles.entries()) {
            if (tiles.has(key))
                continue;
            this._tiles.delete(key);
            for (const sharedEntity of tile.entities.values()) {
                sharedEntity.refcount--;
                if (sharedEntity.refcount === 0) {
                    this._markedForDeletion.add(sharedEntity);
                }
            }
            tile.abortController.abort();
        }
        this._requestRemoveFeatures();
    }
    async _fetchTile(tile) {
        const [ok, featuresOrError] = await this._props
            .fetchTile({ tx: tile.tx, ty: tile.ty, tz: tile.tz, signal: tile.abortController.signal })
            .then((data) => [true, data], (error) => [false, error]);
        if (!ok || !Array.isArray(featuresOrError)) {
            if (!featuresOrError ||
                (featuresOrError instanceof DOMException && featuresOrError.name === 'AbortError')) {
                return;
            }
            throw featuresOrError;
        }
        for (const feature of featuresOrError) {
            const id = this._props.getFeatureId(feature);
            if (tile.entities.has(id))
                continue;
            const existingFeature = this._entities.get(id);
            const SharedEntity = existingFeature !== null && existingFeature !== void 0 ? existingFeature : {
                id,
                feature,
                refcount: 0
            };
            SharedEntity.refcount++;
            tile.entities.set(id, SharedEntity);
            if (!existingFeature) {
                this._entities.set(id, SharedEntity);
                this.__addEntity(SharedEntity);
            }
        }
    }
    _removeEntities() {
        for (const sharedEntity of this._markedForDeletion) {
            if (sharedEntity.refcount !== 0) {
                continue;
            }
            this._entities.delete(sharedEntity.id);
            this.__removeEntity(sharedEntity);
        }
        this._markedForDeletion.clear();
    }
    __addEntity(sharedEntity) {
        var _b, _c;
        if (((_c = (_b = this._props).onFeatureAdd) === null || _c === void 0 ? void 0 : _c.call(_b, sharedEntity.feature)) === false) {
            return;
        }
        if (!sharedEntity.entity) {
            sharedEntity.entity = this._props.entity(sharedEntity.feature);
        }
        this._addDirectChild(sharedEntity.entity);
    }
    __removeEntity(sharedEntity) {
        var _b, _c;
        if (((_c = (_b = this._props).onFeatureRemove) === null || _c === void 0 ? void 0 : _c.call(_b, sharedEntity.feature)) === false) {
            return;
        }
        this._removeDirectChild(sharedEntity.entity);
    }
}
_a = ymaps3.overrideKeyReactify;
YMapEntityTileLoader[_a] = YMapEntityTileLoaderReactifyOverride;
